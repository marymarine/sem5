Задача №1: ”Строка — повторение подстроки”
Ввести непустую строку s. Найти такое наибольшее число k и такую строку t, что s совпадает со строкой t, выписанной k раз подряд. Вывести k.

Задача №2: ”Самое популярное слово”
Ввести построчно текст, состоящий из пробелов, переводов строки и латинских букв, заканчивающийся пустой строкой. Вывести слово, которое чаще других встречается в тексте, если оно такое одно, и —, если таких слов несколько.

Задача №3 ”Буквенные комбинации номера телефона”
На вход алгоритму подается строка, состоящая из цифр от 0 до 9 (номер телефона). Нужно вернуть все возможные комбинации букв, которые могут быть представлены в номере.

Задача №4 ”Граф”
Реализовать структуру данных граф и два способа обхода графа:
∙ в глубину (DFS)
∙ в ширину (BFS)
На вход будет подан массив ребер графа [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]].
В результате должна быть структура, принимающая массив ребер и имеющая две функции, при вызове которых будет выполнять обход вершин. Посещаемые вершины должны выводиться на экран.

Задача №5 ”Поиск пути”
Пусть дан граф, причем каждому его ребру сопоставлен вес (взвешенный граф). Требуется найти путь между двумя заданными вершинами с наименьшим весом. На вход будет подан массив ребер графа [[0, 3, 5], [1, 3, 11], [2, 3, 56], [4, 3, 77], [5, 4, 89]]. Третий параметр - вес ребра. У структуры данных граф должна быть функция, принимающая два параметра (nodeStart, nodeEnd). Данная функция должна вывести кратчайший путь из nodeStart в nodeEnd.

Задача №6 ”Время задержки сети”
У нас есть сеть состоящая из узлов, каждый из которых помечен меткой от 1 до N. Дан список времени распространения сигнала от одного узла до другого в виде направленных ребер. times[i] = (u, v, w), где u- начальный узел, v - конечный узел, и w - время распространения сигнала от начального узла к конечному. Мы отправляем сигнал из узла X и хотим узнать как долго он будет распространяться до всех узлов. Если это невозможно, то возвращаем -1.
